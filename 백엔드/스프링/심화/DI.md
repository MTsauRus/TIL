## 251003 - DI

### 세터 주입

- 선택적 의존성, 재설정을 위해
- set() 메서드 활용
- 해당 의존성이 없어도 객체가 동작하는 데 문제가 없는 경우
- 런타임에 의존성을 변경/재설정해야 하는 경우
- 빈의 속성을 동적으로 변경해야 하는 경우

### 필드 주입

- @Autowired 어노테이션을 활용해 클래스의 필드에 직접 의존성 주입
- 코드가 간결하나 사용 권장 x
- 테스트 용이성 저하: Mock 주입 어려움
  - 필드가 private이므로 Reflaction을 사용하거나, 스프링 컨테이너를 직접 띄워야 함
- 불변성 위반
  - final 사용 불가능
  - 주입된 의존성이 런타임에 변경될 가능성
- 숨겨진 의존성
  - 의존성이 클래스 내부 필드에 숨겨져 있음
  - 개발자가 코드를 열기 전엔 어떤 의존성이 필요한지 알 방법이 없다
  - 단일 책임 원칙 위반을 감지하기 어려움

### 생성자 주입 방식의 우수성

- 불변성(Immutability)
  - final을 사용한 유일한 의존성 선언 방법
  - final 필드는 생성시점에 반드시 초기화되어야 함
  - 즉, 한 번 의존성이 주입되면 앱이 실행되는 동안 변경되지 않음을 보장
  - 이는 객체의 상태를 예측 가능하고 안정적이게 만듦.
- 의존성 명시 및 Null 안전성
  - 필요한 의존성이 생성자의 파라미터로 명확하게 드러남
  - 클래스가 어떤 객체를 필요로 하는지 한눈에 파악할 수 있음
  - 의존성이 누락된 경우 컴파일 시점이나 앱 시작 시점에 실패하므로, 런타임 익셉션 중 하나인 NullPointerException을 원천적으로 방지할 수 있음
- 테스트 용이성
  - 단위 테스트 시 컨테이너 없이 순수 자바 코드로 객체를 생성할 때 생성자에 Mock 객체를 쉽게 전달 가능
- 순환 참조 감지
  - A->B, B->A로 참조하는 순환 참조 문제가 발생했을 때, 생성자 주입 방식은 빈 생성 과정에서 `BeanCurrentlyInCreationException`을 발생시킴.
  - 애플리케이션 구동 시점에 바로 문제를 파악할 수 있음

### `@RequiredArgsConstructor`, `final` -> 상용구 코드 자동화

- 생성자 주입 방식의 유일한 단점은 의존성 추가마다 생성자 코드를 수정해야 하는 것
- `RequiredArgsConstructor` 어노테이션으로 이를 해결할 수 있음
  - 컴파일 시점에 final로 선언된 필드 or @NonNull 어노테이션이 붙은 필드를 파라미터로 받는 생성자를 자동으로 생성해줌.
  - 즉, 사용자는 의존성이 변경될 때마다 constructor 코드를 새로 수정할 필요 없이, 단순히 final을 붙인 필드를 선언만 하면 컴파일 시점에 자동으로 생성자가 만들어짐. 스프링은 이를 보고 의존성을 주입할 것임.

### `@Autowired`의 생략

- 클래스에 생성자가 단 하나만 존재한다면 `@Autowired`를 생략할 수 있음.
- 스프링은 자동으로 유일한 생성자를 의존성 주입에 사용할 대상으로 자동으로 인지하고 처리.
  - 바꿔 말하면, 생성자가 여러개인 경우 반드시 DI에 활용할 생성자를 `@Autowired`를 통해 명시해야 한다는 것을 의미함.

### 생성자 DI 패턴 발전 흐름 정리

1. 자바 언어의 final 키워드로 불변성 원칙을 코드 수준에서 강제
2. final 덕분에 생성자에서 초기화해야 함 -> 생성자 주입 패턴으로 이어짐
3. 이로 인해 발생하는 상용구 코드 문제 (의존성 추가마다 생성자 코드를 변경해야 하는 것)을 `@RequiredArgsConstructor`가 컴파일 시점에 해결
4. Spring 프레임워크가 단일 생성자에 대한 `@Autowired` 생략 제공 -> 코드의 간결화
