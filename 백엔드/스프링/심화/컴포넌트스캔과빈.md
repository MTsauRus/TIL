## 251003 - 빈

### 스프링 빈

- 스프링 앱은 IoC 컨테이너가 관리하는 객체들 - 빈으로 구성됨
- IoC 컨테이너에 의해 인스턴스화되고, 조립되며, 관리되는 객체를 의미함
- 앱의 근간을 형성하는 핵심 구성요소
- 자바에서 new로 생성한 객체는 단순히 자바 객체임
- 하지만 생성과 생명주기를 스프링 컨테이너에 위임하는 순간 빈이 됨
- 생성, 의존성 주입, 생명주기 콜백 호출 등 전반적인 라이프사이클을 포함

### Configuration Metadata

- XML 기반은 생략함
- 자바 기반
  - @Configuration 어노테이션이 붙은 클래스 내에서 @Bean 어노테이션을 메서드에 사용하여 빈을 정의함
- 어노테이션 기반
  - @Component 어노테이션
    - 해당 클래스의 클래스패스를 컨테이너가 스캔, 빈으로 등록

### component scan

- 개발자가 모든 빈을 명시적으로 설정하지 않음
- 특정 관례(어노테이션, 패키지 내 위치 등)에 따라 프레임워크가 자동으로 처리해줌
- @Component
  - 가장 일반적인 목적의 스테레오타입 어노테이션
  - 이를 기반으로 특정 역할을 부여하는 세분화된 어노테이션을 제공
  - @Service
    - 비즈니스 로직을 담당하는 서비스 계층의 컴포넌트
    - 딱히 의미는 없음. 그냥 명시
  - @Repository
    - 데이터 접근 계층(DAO)의 컴포넌트
    - 영속성(JPA, JDBC)에서 발생하는 예외들을 스프링의 DataAccessException으로 변환
  - @Controller/@RestController
    - 프리젠테이션 계층에서 웹 요청을 처리하는 컨트롤러 식별
- 컴포넌트 스캔의 동작 원리
  - @ComponentScan 어노테이션에 의해 활성화
  - @SpringBootApplication이 이를 포함하고 있으므로 굳이 세팅 안해도 됨

### 빈 생명 주기 - Spring IoC 컨테이너의 동작 관점

1. IoC 컨테이너 생성
   - 애플리케이션 시작 시 ApplicationContext 등의 IoC 컨테이너 생성
2. 컴포넌트 스캔 및 BeanDefinition 생성
   - 컨테이너는 지정된 클래스패스를 스캔
   - @Component와 같은 스테레오타입 어노테이션 클래스를 찾음
   - BeanDefinition 생성
     - 클래스명, 스코프, 의존성 등의 메타데이터 포함
3. 인스턴스화(instantiation)
   - BeanDefinition을 바탕으로 빈 객체의 인스턴스 생성
   - Constructor.newInstance() 사용(리플렉션)
4. 의존성 주입(DI)
   - 생성된 인스턴스에 필요한 의존 객체(다른 빈) 주입
5. 초기화 및 소멸
   - 의존성 주입 후 @PostConstruct와 같은 초기화 콜백 메서드 호출
   - 앱에서 빈 사용 가능
   - 컨테이너 종료 시 PreDestroy와 같은 소멸 콜백 호출

### 완전한 빈 생명주기

1. 인스턴스화 및 속성 설정
   - 컨테이너가 빈 정의를 기반으로 해당 클래스의 인스턴스를 생성
   - 클래스의 생성자를 호출
   - 객체가 메모리에 생성됨
   - 인스턴스화 직후 DI를 통해 의존성이 주입됨
2. Aware 인터페이스의 역할
   - 만약 빈이 BeanNameAware, BeanFactoryAware와 같은 Aware인터페이스를 구현했다면 스프링 컨테이너는 해당 인터페이스의 set\*() 메서드를 호출
   - 해당 빈은 다음 정보를 알 수 있음
     - 부여받은 이름
     - 자신을 관리하는 BeanFactory
     - 자신이 속한 ApplicationContext
   - 하지만, 코드를 스프링 프레임워크에 종속시키므로 현대 앱에서는 사용 빈도가 낮아짐
3. BeanPostProcessor -> 초기화 전처리
   - BeanPostProcessor 구현체의 postProcessBeforeInitialization 메서드가 호출됨
   - 의존성 주입 후
   - @PostConstruct 호출 전
   - 원본 빈 인스턴스 수정
   - 프록시 객체로 대체하여 반환 가능
4. 초기화 콜백
   - 빈의 초기화 메서드 호출
   - 빈이 사용 가능한 상태가 되도록 준비시킴
   - 다음의 엄격한 순서를 따름
   - 1. @PostConstruct
   - 2. InitializingBean을 구현한 경우, afterPropertiesSet()
   - 3. init-method 속성으로 지정된 커스텀 초기화 메서드
   - 이 지점에서 개발자가 리소스 할당이나 사전 계산과 같은 커스텀 초기화 로직을 추가함
   - 공식에서는 코드가 인터페이스에 종속되지 않게 @PostConstruct를 가장 권장
5. BeanPostProcessor 초기화, 프록시 생성
   - BeanPostProcessor의 두 번째 메서드인 `postProcessAfterInitialization` 호출
   - 이 지점에서 AOP 동작
     - @Transactional이 있는 경우 이 지점에서 빈을 가로챔
     - 원본 빈을 감싸는 프록시 객체를 동적으로 생성
     - 이 프록시는 트랜잭션 시작, 커밋, 롤백과 같은 부가 기능을 원본 메서드 호출 전후에 추가하는 역할 수행
     - 그 후 컨테이너에 저장
     - 다른 빈에 주입되는 것은 원본 객체가 아닌, 프록시 객체임
6. 빈 사용
   - 모든 초기화 및 후처리 과정이 끝남
   - 다른 애플리케이션에서 사용할 준비가 됨
   - 다른 빈에 의존성으로 주입
   - ApplicationContext.getBean()으로 직접 조회 및 사용
7. 소멸 콜백

- 앱이 종료되어 컨테이너가 닫힐 때
- 싱글톤 빈들의 소멸 콜백 호출
- 초기화와 역순으로 진행됨
  - 1. @PreDestroy 메서드
  - 2. DisposableBean을 구혀한 경우 destroy() 메서드
  - 3. destroy-method 속성으로 지정된 커스텀 소멸 메서드
- DB 커넥션 닫기
- 스레드 풀 종료
- 리소스 해제
- 단, 주로 싱글톤 스코프 빈에만 적용됨
- 프로토타입 스코프 빈은 클라이언트 코드에 전달하고 더이상 관리되지 않으므로 소멸 콜백이 호출되지 않음
  - 이를 정리하는 것은 클라이언트의 책임

### 빈 스코프를 통한 상태 및 컨텍스트 관리

- singlton scope
  - 상태 없는 기본값
  - 스프링 빈의 기본 스코프
  - 스프링 IoC 컨테이너 당 하나의 인스턴스만 생성됨
  - 컨테이너는 유일한 인스턴스를 내부 캐시에 저장
  - 해당 빈에 대한 요청, 참조에 대해 캐시된 객체를 반환
  - stateless 객체에 사용됨
  - 서비스, 레포지토리, 설정 클래스 등
  - 여러 스레드에서 동시 접근되므로 스레드 안전성을 고려해야 함
  - 중요한 점은, JVM 당 하나가 아니라 컨테이너 당 하나임.
- prototype scope
  - 요청 시마다 생성되는, 상태 있는 인스턴스
  - 싱글톤과 정 반대
  - getBean()
  - 의존성 주입 시 매번 새로운 인스턴스 생성
  - stateful 객체
  - 사용자가 임시로 저장하는 객체, 매번 새로운 설정으로 초기화되어야 하는 빌더 객체 등
  - 컨테이너가 생명 주기를 관리하지 않음
  - 생명 주기 관리 책임은 클라이언트에 있음
- 웹 전용 스코프 - request, session, application
  - ApplicationContext 환경에서 유효
  - 서블릿 API와 연관된 생명주기
  - request
    - 하나의 HTTP 요청이 시작되고 끝날 때까지 단일 빈 인스턴스가 생성/유지
    - 요청 처리 중 필요한 데이터(사용자 정보, 검색 결과)를 담는 용도
  - session
    - 하나의 HTTP 세션이 유지되는 동안 단일 빈 인스턴스가 존재
    - 로그인 정보, 장바구니 등 세션동안 유지되어야 하는 데이터 관리
  - application
    - ServletContext 생명주기와 동일
    - 웹앱 전체에 걸쳐 하나의 빈 인스턴스만 존재
    - 사실상 싱글톤이지만, 웹 컨텍스트에 종속됨
- scope proxy
  - 스코프 불일치 문제 해결
  - 서로 다른 생명주기를 주입할 때 문제가 발생
  - 싱글톤 빈(생명주기 긺)에 리퀘스트 빈(짧음) 주입하는 경우
    - 싱글톤 빈은 생성될 떄 딱 한 번 의존성이 주입됨
    - 즉, 싱글톤 빈은 동일한 리퀘스트 스코프 빈의 인스턴스만을 참조하게 됨
    - 각기 다른 HTTP 요청에 독립적일 수 없음
  - 스코프 프록시 메커니즘
    - 리퀘스트/세션 스코프 빈을 정의할 때 프록시 모드를 활성화
    - @Scope 사용
    - 프록시 객체를 싱글톤 빈에 주입함
    - 메서드가 호출될 때마다 HTTP 요청/세션에 맞는 실제 빈 인스턴스를 찾아내어 호출을 위임함
    -
