## 데이터 타입 분류

- 기본 타입
  - primitive
  - byte, char, short, int, long
  - float, double
  - boolean
- 참조 타입
  - reference
  - 배열, 열거, 클래스, 인터페이스

## 스택, 힙

- 스택
  - 메서드가 호출되면 프레임이 스택에 생성
  - 프레임 내부에는 로컬 변수 스택이 존재
  - 변수들은 모두 스택 영역에 생성
  - 기본 타입 변수, 참조 타입 변수 모두
  - 기본 타입 변수의 경우 값 그자체가 스택에 저장
  - 참조 타입 변수의 경우 값이 저장되어 있는 주소값이 저장
- 힙
  - 객체가 생성되는 영역
  - 객체의 번지수(주소)는 힙에 존재
  - 여기의 주소를 스택 / 메서드 영역에서 참조해갈 수 있음
  - 힙에 실제 객체가 저장되어 있음
- 메서드 영역
  - 상수, 정적(static) 필드, 메서드 코드, 생성자 코드

## 참조 타입의 연산

- 참조 타입에 ==, != 연산을 사용하면 주소값을 비교하는 연산이 된다.
  - 즉, 의도하지 않은 연산 결과를 초래할 수 있음.
  - 주로 if문에서 같은 객체를 참조하고 있는지 비교할 때 사용됨

## garbage collecting

- 참조 변수의 값이 null인 경우, 힙 영역에 실제 객체가 존재한다고 할지라도 이 객체는 참조받을 수 없다.
- 자바의 가비지 컬렉터는 참조되지 않는 힙 영역의 객체를 자동으로 수거한다.
  ```java
  String hobby = "여행";
  hobby = "게임";
  ```
- 이 경우, 힙 영역에는 "여행" 객체와 "게임" 객체가 모두 존재한다.
- 하지만 hobby는 "게임" 객체의 주소만을 참조하고 있다.
- 따라서 "여행" 객체는 어디에서도 접근할 수 없으므로 가비지 컬렉터에 의해 수거된다.

## String

- 동일 문자열을 참조하는 두 개의 참조 변수가 있을 경우, 이 참조 변수의 값은 같다.
  - 즉, 힙 영역에 "예시문자열"이 있고, `String s1 = "예시문자열", String s2 = "예시문자열"`이면 s1 == s2이다. (참조값이 같다.)
- 하지만, `new String()`으로 만든 객체는 객체 내 값이 동일하더라도 다른 객체 취급된다.
- `String s1 = new String("s");`
- `String s2 = new String("s");`
- `s1 != s2` <br>
- 내부 문자열 값의 동일 여부를 판단할 때에는 equals()를 사용하자.

## 문자열 관련 메서드

- charAt
  ```java
    String a = "자바 프로그래밍";
    char c = a.charAt(2);
    // c = ' ';
  ```
- length
- replace  
  `newString = oldString.replace("자바", "java");`
  - <mark>참고로, String 문자열은 변경이 불가능하므로 replace()를 실행하는 경우 아예 새로운 문자열을 만들게 된다.</mark>
  - 즉 newString != oldString(참조 값이 다름)
  -
