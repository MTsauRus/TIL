# D+16 JAVA

## abstract class
- 부모 클래스 Vehicle, 자식 클래스 1 DiesselSUV, 자식 클래스 2 ElectricCar이 있음
- 두 자식 클래스는 addFuel()을 override하고 있음
- <mark>이때 부모 클래스 Vehicle에서의 addFuel() 구현부는 무의미함</mark>
  - 하지만 메서드 형태는 있어야 함. 자식 클래스에서 override해야 하므로.

### 만드는법
1. 선언부 남기고 구현부 날리고 세미콜론으로 대체
2. 메서드 선언부에 abstract 키워드 추가
3. 클래스는 객체를 생성할 수 없으므로 클래스에도 abstract 추가

### 추상 클래스 특징
- abstract 클래스는 상속 전용 클래스
- 자식은 abstract 메서드를 재정의할 책임이 있음
- abstract 클래스는 구현부가 없는 메서드를 가지고 있으므로 객체를 생성할 수 없음
- 하지만 상위 클래스 타입으로써 자식 참조는 가능 (다형성)

- 만약 조상 클래스에서 상속받은 abstract 메서드를 자식 클래스가 재정의하지 않은 경우, 클래스 내부에 abstract 메서드가 있는 상황이므로 자식 클래스 역시 abstract로 선언되어야 함.
- <mark>자식 클래스에게 구현을 강제한다는 의의가 있음 (안하면 컴파일 에러) -> 프로그램 안정성 기여</mark>
- ![alt text](image-5.png)
  - 추상 메서드를 재정의하거나
  - 자식 클래스를 추상 클래스로 만들거나


## Interface
- 최고 수준의 추상화 단계
- 일반 메서드는 모두 abstract 형태
- 모든 멤버 변수는 <mark>public static final</mark>만 가능함
  - 그래서 인터페이스 내에서 변수 만들면 다 저거임 생략해도됨
- 모든 메서드는 public abstract임 물론 생략해도됨

```java
public interface MyInterface {
    public static final int MEMBER1 = 10;
    int MEMBER2 = 20; // psf 생략가능

    public abstract void method1(int param);
    method2(int param); // public abstract 생략 가능
}
```

### 인터페이스 상속
- 인터페이스는 인터페이스를 상속 가능함
- 클래스와 다르게 다중 상속 가능
  - 다중 상속했을 때 구현할 메서드 자체가 없으므로 다중상속 받아도 상관이 없음
- 다형성은 조상 클래스, 조상 인터페이스 다 가능
- 조상 인터페이스로 선언하고 자식 객체를 붙일 수 있음
  - `Heroable h = new IronMan();`
- is able to 관계
- 
## 인터페이스의 필요성
1. 구현의 강제화
2. 인터페이스를 통한 간접적 클래스 사용 -> 손쉬운 모듈 교체
  - 자바에서 JDBC 인터페이스를 선언해놓고, 나중에 MySQL, Oracle 구현체로 바꿔 끼면 됨
3. 서로 상속 관계가 없는 클래스에게 인터페이스를 통한 관계 부여로 다형성 확장
```java
void foo() {
    Chargeable[] objs = {
        new HandPhone(),
        new ElectricShaver()
    };

    for (Chargeable[] obj : objs) {
        obj.charge();
    }
}
```
  - Chargeable 인터페이스로 핸드폰과 면도기를 묶을 수 있음.
  - chargeable obj로 선언받고, 서로 다른 클래스이지만 동시에 charge를 사용할 수 있음. 
```java
public interface Chargeable {
    void charge();
}
public class Phone {

}
public class Shaver {

}
public class HandPhone extends Phone implements Chargeable{
	@Override
	public void charge() {
		System.out.println("phone charge");
	}
}
public class ElectricShaver extends Shaver implements Chargeable{
	@Override
	public void charge() {
		System.out.println("shaver charge");
	}
}
public class RelationShipTest {
    public static void main(String[] args) {
        Object[] objs = { new HandPhone(), new Shaver(), new Phone(), new ElectricShaver() };

        for (Object obj : objs) {
        	if (obj instanceof Chargeable c)
        		c.charge();
        }
    }
}
```
  - 서로 관련없는 HandPhone과 ElectricShaver 간 관계를 Chargeable로 맺음.

4. 모듈 간 독립적 프로그래밍 가능
   - 계산기를 구현하는 두 팀이 있다고 하자. A는 프론트, B는 계산 로직 구현 담당임
   - A팀은 Calculator 인터페이스를 상속받은 CalculatorStub을 대충 구현한다.
    - CalculatorClient를 구현하고, Interface Calculator를 has a 관계로 포함시켜 구현할 수 있다. 
    - B팀은 Calculator를 임플리먼트한 CalculatorImpl를 만들 수 있다. 

```java
// 프론트 팀
class CalculatorClient {
  Calculator calcLogic = new CalculatorStub();
  // Calculator calcLogic = new CalculatorImpl(); // 다 완성한 후 이걸로 갈아끼우면 됨

  public void add() {
    System.out.println("첫 번째 정수를 입력하시오.");
    Scanner scanner = new Scanner(System.in);
    int a = scanner.nextInt();
    System.out.println("두 번째 정수를 입력하시오.");
    int b = scanner.nextInt();
    System.out.printf("결과: %d+%d=%d%n", a, b, calcLogic.add(a, b));
    scanner.close();
  }
}


// 백 팀
public class CalculatorImpl implements Calculator{

	@Override
	public int add(int a, int b) {
		return a + b;
	}
}
```
   - 각자 Interface Calculator를 상속받아 병렬적으로 업무 수행 가능


## default, static, private
### default
- 인터페이스에 선언된 구현부가 있는 일반 메서드
- 접근 제한자는 public으로 한정 (생략 가능)
```java
interface foo {
    defualt void method() {
        sysout("");
    }
}
```
  - 기존 인터페이스에 메서드를 추가해야 하는 경우
  - 하지만 abstract로 만드는 경우 모든 구현체가 이를 오버라이드 해야 함
  - default 메서드는 abstract가 아니므로 구현체가 오버라이드하지 않아도 됨 (물론 필요하다면 재정의해도 됨)

  - MyClass가 MyInterFace를 impl하고, MySuperClass를 상속받았다. superClass도 method()를, 인터페이스도 method()를 default로 가지고 있을 때, MyClass에서 method를 오버라이드하지 않은 경우 superClass의 method가 우선 적용된다. (우선순위 super >> default)

  - 하나의 인터페이스에서 default method가 있고, 다른 인터페이스에서 동일한 이름의 method(default와 무관)가 있을 때, 이를 구현하는 하위 클래스는 반드시 override하여 충돌을 방지해야 한다. 

### static
- 인터페이스 내에서도 static 메서드를 사용할 수 있다.
- 구현체 없이 InterfaceName.staticMethod() 해서 접근 가능

### private method
- interface 내부에 구현부를 가진 method가 등장하면서, 외부에 공개할 필요 없는 메서드가 발생
- private 선언한 메서드는 default처리할 수 없음. (당연히 이 인터페이스를 impl한다면 하위 클래스에서 default 메서드를 사용할 수 있음. 이 경우 private가 아니므로)
- 단, static 처리는 가능. 

- 아니 그럼 private static 언제 씀???
```java
public interface ConnectionUtil {

    // 외부에서 쓰는 메서드 1
    static void connectMySql() {
        // 공통 검증 로직 호출
        validate("MySQL"); 
        System.out.println("MySQL 연결...");
    }

    // 외부에서 쓰는 메서드 2
    static void connectOracle() {
        // 공통 검증 로직 호출
        validate("Oracle");
        System.out.println("Oracle 연결...");
    }

    // [핵심] 내부 전용 도우미 (private static)
    // 1. static 메서드에서 불러야 하니까 static이어야 함.
    // 2. 외부엔 보여주기 싫으니까 private이어야 함.
    private static void validate(String type) {
        if (type == null || type.length() == 0) {
            throw new IllegalArgumentException("DB 타입 에러");
        }
        // 복잡한 로직이 더 있다고 가정...
    }
}
```
- 다른 public static 메서드를 돕기 위해 사용.
- 다른 public static에서 호출하기 위해서는 반드시 static이어야 하는데, 이 로직을 공개하고 싶지 않은 경우 private static을 사용한다. 