# D+13

# JAVA

## 기본 문법
- 기본형 vs 참조형


## 문자열
- 참조형
- `String str1 = "Hello";`
- `String str2 = "Hello";`
  - 두 문자열은 같은 내용, 같은 객체임
  - String pool에 생성
- `String str3 = new String("hello");`
- `String str4 = new String("hello"); `
  - 두 문자열은 다른 객체
  - Heap에 생성 <br><br>
- Text Block - Multi line 적용 가능 (java15~)

### formatting
- .precision
  - %.2f
- conversion
  - d, f, s, c, b(boolean), x(16), o(8), e(지수형 부동소수점)
  
  
### overflow
- `int a = Integer.MAX_VALUE;`
- `int b = a + 1;` 
- -> -2147~~이 됨.

### 부동 소수점 오류
```java
	double d1 = 2.0;
    double d2 = 1.1;
    double d3 = d1 - d2;
    // 0.8999999999
    
    // 이거 사용
    BigDecimal b1 = new BigDecimal("2.0");
```

### 형변환
- primitive는 primitive끼리, reference는 reference끼리

- 명시적 형변환
```java
	double d = 100.5;
    int result = (int) d;
    
    // 100, 100.5
```
- 묵시적 형변환
```java
	byte b = 10;
    int i = (int)b;
    int i2 = b;
 ```  
   - 작은 타입 -> 큰 타입은 묵시적 변환해도 상관이 없음
   - 큰 타입 -> 작은 타입은 손실 발생 -> 명시적 형변환해야 함. 
- byte -> short -> int -> long -> float -> double
- (char -> int)

```java
int i1 = Integer.MAX_VALUE;
long l1 = i1 + 1; // 오버플로우
long l2 = (long) (i1 + 1); // 오버플로우
long l3 = (long) i1 + 1; // 정상
```

### 기본형 <-> 객체형
- byte - Byte
- int - Integer
- char - Character
  <br>
 - 기본형 <-> 참조형
 - 참조형 <-> 문자열
 - 문자열 <-> 기본형
  - `Integer.parseInt(String str);`
  - `Integer iw2 = i; // 오토박싱 가능`
  
### 산술 연산 주의사항
- 산술 이항 연산자는 피연산자의 타입을 일치시킴
- 피연산자 크기가 4Byte(int) 미만이면 int로 변경
- 두 피연산자 중 큰 타입으로 형 변환 후 진행

### switch expression
```java 
// java 8
int month = 3;
int day = -1;
switch (month) {
    case 2:
        day = 29;
        break;
    case 4:
    case 6:
    case 9:
    case 11:
        day = 30;
        break;
    default:
        day = 31;
}

// java 14
int month = 3;
int day = switch (month) {
    case 2 -> 29;
    case 4, 6, 9, 11 -> 30;
    default -> {
        yield 31;
    }
};
```
- <mark>switch(expression)의 expression에는 {byte, short, int, char, String} 만 들어갈 수 있다.</mark> 
- 

## 배열
  동일한 타입의 0개 이상 데이터를 하나의 연속된 메모리 공간에서 관리
### 초기화
- boolean -> false
- char -> `\u0000` (null 문자)
- 참조형 -> null
- 나머지 -> 0

### 선언
`int[] points = new int[3];`
- `int[] points;`
  - 배열 선언. 참조변수 points를 잡아둠
- `new int[3];`
  - 0x100에 0을 값으로 가지는 메모리 공간 확보
- `points = new int[3];`
  - points에 0x100 참조 값 할당
- `Arrays.toString();`으로 출력

#### 연습문제
String "1234567890"의 각 문자를 char[], int[]에 저장하고 출력

```java

```

### Array 만들기
생성과 동시에 초기화
- `int[] c = {1,2,3,4,5};`

### for-each with Array
```java
int[] intArray = {1,2,3,4,5};
for (int x : intArray) {
    System.out.println(x);
} // 단, idx를 사용할 수 없음
```

### 배열의 크기는 불변
- 최초 메모리 할당 이후 변경 불가
- 다른 값 변경은 가능하나 추가/삭제는 불가
```java
int[] nums = {1,2,3};
nums = new int[] {1,2,3,4};
// nums는 참조변수임
// 즉, {1,2,3},{1,2,3,4}는 다른 배열. 메모리에 새로 배열을 만드는 것임
// {1,2,3}은 GC가 처리
```

### 배열 복사
- `System.arrayCopy`
- `Arrays.copyOf`

## 다차원 배열
- `int[][] intArray = {{1,2,3}, {4,5,6}};`
- 2차원 배열만 선언할 수 있다. 
  - `int[][] intArray = new int[4][];`



# GIT

## gitignore.io
- 만들어주는 프로그램
- java, eclipse, windows 등 입력해주면 자동으로 ignore파일을 만들어줌
- src, bin 폴더 있는 같은 디렉토리 레벨에 넣어주고 커밋푸시 하면 됨

## git 관련
- 로컬 디렉토리 -> 스테이징 -> 로컬 리포지토리 -> 리모트 리포지토리


- `git init`
  - local 작업폴더를 local repository로 만들어주는 명령어
  - 작업폴더 겸 리포지토리가 됨
- `git remote add origin https://lab.ssafy.com/qksrurwnsql/mygitremote.git`
  - 원격 리포지토리와 로컬 리포지토리를 연결
- `git add .`
  - 작업 디렉토리 안에 있는 <mark>>변경된</mark>' 파일을 'staging area'로 이동
- `git commit -m "Initial commit"`
  - -m으로 커밋 메시지 넣어줘야 함
  - 스테이징 -> 로컬 리포지토리
- `git push --set-upstream origin master`
  - 원격 리포지토리로 업로드