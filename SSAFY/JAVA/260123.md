# D+17 JAVA

## generic
- 다양한 타입의 객체를 다루는 메서드, 컬렉션 클래스에서 <mark>컴파일 시에 타입 체크</mark>
  - 컴파일 타임에 타입 파라미터들이 대입된 타입으로 대체됨
  - 제너릭 안쓰면 런타임 에러 발생 가능성. 런타임에러는 손실이 너무 큼
  - 미리 사용할 타입을 명시해서 형 변환을 하지 않아도 되게 함

```java
public interface Interface<T>{}
```
- 형인자(Type parameter)
  - 단순히 임의의 참조형 타입을 말함. 
  - (T: reference Type)
  - (E: element)
  - (K: key)
  - (V: value)
- 변수 쪽과 생성 쪽의 타입은 반드시 같아야 함
  - `ClassName<Number> generic = new ClassName<Number>;`
```java
class GenericBox<T> {
    private T some;
}
```
- T는 타입 선언 시 결정됨


### 제네릭 주의사항
- raw type 사용과 @SuppressWarnings
  - raw type은 제네릭 <>를 사용하지 않고 그냥 쓸 때.
  - `@SuppressWarnings({"rawtypes", "unused"})` 하면 경고가 안뜸. 
  - 근데 제네릭 쓰라고 만들어놨는데 왜 굳이 안씀?

- 헷갈리는 사용법 (상속 관계)
```java
- public void confusing() {
    GenericBox<Person> pbox = new GenericBox<>();
    pbox.setSome(new Person());
    pbox.setSome(new SpiderMan()); // spiderMan도 가능. 얘도 사람임

    // pbox = new GenericBox<SpiderMan>(); 이건 안됨. Person을 담는 박스와 SpiderMan을 담는 박스 간에 상속 관계가 없음. 변수 이름을 다시 해야 함. 
}
```

- 타입 파라미터는 인스턴스 레벨에서 결정됨
  - 클래스 레벨의 static 멤버에서는 사용 불가
  - `static I item; ` << 이거 안됨. static레벨에선 제네릭 불가능함

- Generic은 컴파일 타임에 지정한 타입으로 존재함.
  - <mark>런타임에는 타입 정보를 소거함. (단순 오브젝트로 관리함)</mark>
  - 컴파일러가 이미 타입을 체크했기 때문에 런타임에는 자유롭게 사용됨

- Generic 타입 배열 생성 불가
  - 배열은 런타임에 객체 정보를 유지해야 하고, 동일한 타입 객체만 처리하기 때문.
  - 제네릭은 런타임에 타입 정보 소거한다고 말했음

- raw 타입 객체의 형 변환 주의
  - 실제 메모리에는 모든 객체를 다 담을 수 있으므로 형이 보장되지 못함
  `box[1] = (GenericBox) (box);` 이거 하지 마

### 한정형 형인자
- extends 사용해서 특정 타입 이하의 타입만 허용
  - 숫자만 받고 싶을 때 `class NumberBox<T extends Number> {} ` 하면 Number를 상속받은 자식 클래스만 사용 가능. (Integer, Byte, Short...)

- 인터페이스로 제한할 때에도 extends 씀.
  - 클래스와 함께 인터페이스 제약 조건을 여러 개 묶는 경우 &로 묶음. 
  - `class Generic<T extends Number & Cloneable & Comparable<String>>{}`



### 제네릭 메서드
- 파라미터와 리턴타입으로 타입 파라미터를 갖는 메서드
- `public <p> p method (P p) {} `
  - 메서드가 호출되는 시점에 결정됨

```java
psvm () {
    GenericClass<String> tmp - new GenericClass<>();
    tmp.<Long>method(20L); // 명시적으로 타입 결정.
    tmp.method(10); // 묵시적 타입 결정
}
```

### 와일드카드 자료형
- 비한정형: `Generic_type<?>`
- 한정형: `Generic_type<? extends T>`, `Generic_type<? super T>` 
- 
### PECS
- Producer Extends
- Consumer Super

```java
class Animal{}
class Mammal extends Animal{}
class Tiger extends Mammal{}
class Rabbit extends Mammal{}



class MyBox<X> {
	private int num;
	private X what;
	
	public int getNum() {
		return num;
	}
	public void setNum(int num) {
		this.num = num;
	}
	public X getWhat() {
		return what;
	}
	public void setWhat(X what) {
		this.what = what;
	}

}


public class GenericTest {
	// method1에서 T라는 타입이 사용되는데, 그 타입이 MyBox<? super Mammal>임. 
	// 상속구조에서, <> 안에 Mammal 이상만 올 수 있음. 즉, 최소 Mammal이 보장됨. Mammal이 최하위. 적어도 Mammal은 옴
	// super -> data를 저장하는 용도로 사용 (CS)
	// super -> writeonly
	public static <T> void method1(MyBox<? super Mammal> box) {
		box.setWhat(new Mammal());
		box.setWhat(new Rabbit());
		// box.setWhat(new Animal()); 이거 안 됨. MyBox<Mammal>일 수도 있는데 Mammal what = new Animal() 당연히 안되겠지?
	}
	
	// <> 안에 최대 Mammal이 옴. Mammal <- Tiger, Rabbit. Mammal이 최상위. 
	// extends -> data를 꺼내 쓰는 용도로 사용 (PE)
	// extends -> readonly
	public static <T> void method2(MyBox<? extends Mammal> box) {
		Mammal m = box.getWhat();
		Animal a = box.getWhat(); // 가능. Mammal은 Animal이므로.
		// Rabbit r = box.getWhat(); 안 됨. 만약 box 안에 Mammal이 들어있다면? Rabbit으로 Mammal을 받을 수 없음.
	} 
	
	
	public void test() {
		MyBox<Animal> b1 = new MyBox<>();
		b1.setWhat(new Animal());
		b1.setWhat(new Mammal()); // 가능. Animal의 자식
		b1.setWhat(new Tiger()); // 가능. Animal <- Mammal <- Tiger
		
		MyBox<Mammal> b2 = new MyBox<>();
		// b1 = b2; 이건 안됨. <> 안에 있는 타입을 집어 넣는 것은 되는데, 박스와 박스 간 상속관계는 아무 의미가 없음!!!!!
		
	}

	public static void main(String[] args) {
		int num = 99;
		// deprecated
		//Integer i = new Integer(num);
		// 이제 알아서 오토박싱/오토언박싱 해주니까 걍 신경쓰지 말고 쓰자. Integer i = 30; 이렇게. 
		
		// TODO Auto-generated method stub
		MyBox<String> b1 = new MyBox<>();
		MyBox<Integer> b2 = new MyBox<>();
		MyBox<Circle> b3 = new MyBox<>();
	
		
		b1.setWhat("hello");
		b2.setWhat(123); // <- Integer로 알아서 wrapping해줌.
		b3.setWhat(new Circle(3));
		
		System.out.println(b1.getWhat());
		System.out.println(b2.getWhat());
		System.out.println(b3.getWhat());
	
	}

}

```





## enum
- 열거형 데이터 타입
  - 데이터가 몇 가지 한정된 값만을 갖는 형태로 구성되는 경우
  - java.lang.Enum
  - class 대신 enum
    ```java
    enum Grade {
        SALES, PART_TIME_JOB, NORMAL
    }

    ```
  - 상수 선언 naming rule 따름. (대문자_대문자)
  - 클래스와 동일하게 선언.
  - 할당 가능한 값은 enum 상수, null로 한정됨.

- 값 비교 시 단순히 값 뿐 아니라 타입에 대해서도 체크 가능 -> 논리적 오류 방지

```java
private static final int DO_NOT_USED = 10;

//~~~

get.calcSalNormal(DO_NOT_USED); // 쓰면 안되는 상수를 써도 그냥 동작함. 
// 이를 방지하기 위해 enum 클래스를 사전에 만들어놓고 그 값만 사용하게끔 강제할 수 있음.
```
### enum 멤버 변수
- 일반 클래스처럼 Enum에도 멤버 변수, 메서드 추가 가능.
- 단 enum 상수 선언 끝에 ; 써줘야 함
- 생성자도 사용 가능. 단 반드시 private
  - 내부 상수 선언 시 값 할당용


### Integer caching
Integer a = -128~127까지, 자주 쓰는건 a == b 사용 가능.
근데 a = 200, b = 200 하면 false 뜸. 이런거 헷갈리니까 그냥 equals 써. 





## annotation
- 컴파일러, JVM, 프레임워크 등이 보는 주석
  - 주석으로 소스코드에 메타데이터를 삽입하는 형태

### JDK의 기본 annotation
- @Deprecated
  - 컴파일러에게 해당 메서드가 deprecated되었다고 알림
- @Override
  - 컴파일러에게 해당 메서드가 ovveride임을 알림.
- @SuppressWarnings
  - 컴파일러에게 사소한 오류 신경쓰지 말라고 알림

### 어노테이션 분석
- 메타 어노테이션
  - 어노테이션 설정을 위한 어노테이션
  - @Documented
    - JavaDoc 만들 때 이 어노테이션이 문서에 표시되어야 함
  - @Inherited
    - 어노테이션이 하위 클래스에 상속됨
  - @Repeatable
    - 해당 어노테이션이 반복해서 적용되는지 표시
  - @Retention
    - 어느 단계까지 어노테이션 정보를 유지할지
    - RetentionPolicy enum이 있음
  - <mark>@Target</mark>
    - 해당 어노테이션을 어디에 쓸 수 있는가
    - ElementType enum이 있음
    - TYPE, FIELD, METHOD, PARAMETER... 

- 속성 어노테이션
  - 추상 메서드처럼 선언
  - 메서드 이름 -> 속성이름, 리턴타입 -> 속성타입
  - 일반 속성처럼 키=값으로 사용됨


## Collection framework
- 가장 기본적인 구조 배열
  - 얘는 동일 타입만 관리됨
  - 그래서 다형성 나옴
  - 근데 object로만 꺼낼 수 있음. 캐스팅해야됨
  - 그래서 제네릭 씀
  - 귀찮
- Collection Framework
  - java.util에 있음
  - 다수의 데이터를 쉽게 처리하는 방법을 제공함

```
    [iterable]
        ^
        |
    [Collection]
    /       \
   /         \
[List]      [Set]
```
- List
  - 순서있음
  - 중복허용
  - ArrayList, LinkedList
- Set
  - 순서알빠노
  - 중복허락x
  - HashSet, TreeSet
- Map
  - 키벨류
  - 순서없음
  - 키중복불가, 값중복가능
  - HashMap, TreeMap

### 컬렉션 인터페이스
- 추가
  - add(E e)
  - addAll(Collection <? extends E> c)
- 조회
  - contains
  - containsAll
  - equals
  - isEmpty
  - iterator
    - 예전엔 set에서 많이 썼었는데 이제 set에서도 foreach 가능
  - size
- 삭제
  - clear
  - remove
  - removeAll 
- 수정
- 기타
  - toArray()

```markdown
# Java Collection Framework Hierarchy

## 1. Collection (Iterable)
Iterable <Interface>
└── Collection <Interface>
    ├── List <Interface> : [순서 O, 중복 O]
    │   ├── ArrayList      (조회 빠름, 삽입/삭제 느림)
    │   ├── LinkedList     (조회 느림, 삽입/삭제 빠름)
    │   └── Vector         (Legacy: 동기화 보장)
    │       └── Stack      (Legacy: LIFO)
    │
    ├── Set <Interface> : [순서 X, 중복 X]
    │   ├── HashSet        (가장 빠름, 순서 없음)
    │   ├── LinkedHashSet  (입력 순서 보장)
    │   └── SortedSet <Interface>
    │       └── TreeSet    (이진 트리, 자동 정렬)
    │
    └── Queue <Interface> : [FIFO]
        ├── PriorityQueue  (우선순위 큐)
        └── Deque <Interface>
            ├── ArrayDeque (Stack 대용으로 추천)
            └── LinkedList (List이자 Deque임)

## 2. Map (Not a Collection)
Map <Interface> : [Key:Value 쌍, Key 중복 X]
├── HashMap        (가장 많이 씀, 순서 없음)
├── LinkedHashMap  (입력 순서 보장)
├── Hashtable      (Legacy: 동기화 보장)
└── SortedMap <Interface>
    └── TreeMap    (Key 기준 자동 정렬)
```

### List
- 추가
  - add(int idx, E element)
    - 특정위치 삽입가능, O(N)
  - addAll(idx, Collection c)
- 조회
  - get
  - indexOf
  - lastIndexOf
  - listIterator
- 삭제
  - remove
- 수정
  - set(idx, e)
- 기타
  - subList(from, to)

### List 자동확장 소스분석
- 10p
- add -> ensureCapacityInternal -> ensurExplicitCapacity -> grow
- 미리 크기 지정해서 만드는게 훨씬 효율적임

### 배열과 ArrayList
- 배열의 장점
  - 가장 기본적 사용쉬움
  - 접근빠름
- 단점
  - 크기변경불가
  - 추가 데이터를 위해 새로운 배열을 만들고 복사
  - 비순차적 데이터의 추가, 삭제에 많은 시간이 걸림
  - 만약 12345번 데이터가 있고 1번 삭제하면 2345가 앞으로 한칸씩 당겨짐 -> O(N)

- 배열을 사용하는 ArrayList도 태생적으로 배열의 장단점을 공유함

### LinkedList
- 각 요소를 Node로 정의하고, Node는 다음 요소의 참조값과 데이터로 구성됨
- 각 요소가 다음 요소의 링크 정보를 가지며, 연속적으로 구성될 필요가 없음
- 데이터 추가/삭제가 O(1)임. ArrayList와 다름. 


- 순차적으로 자료 추가 시 속도 Array >> linked
- 비순차(중간삽입) 자료 추가 시 속도 Array <<<<<<<< linked
- 조회 시 속도 Array >>>>>>> linked

- 정적 데이터, 단순 데이터 조회 -> ArrayList
- 동적인 데이터 추가/삭제 많은 경우 LinkedList

### 삭제 시 주의
- index를 이용한 for문, arrayList에서
  - 0 -> size()까지 가면 안돼요.
  - 삭제하고 앞으로 하나씩 당기니까 큰일남. 
  - 순회마다 삭제 시 인덱스-- 하든가, 아님 걍 거꾸로 돌리든가.

- forEach 시 컬렉션 크기가 불변해야 함
- 삭제/삽입 시 크기가 바뀜 -> 익셉션뜸


### collection, generic
- 배열은 공변 자료형 (covariant)
- 제네릭은 불변 자료형(invariant)
  - List<Object> list = new ArrayList<Object>(); 이거 앞뒤 <>는 당연히 같아야 함.

## Set
- 입력 순서를 관리하지 않음
- 중복 허용 x
- (효율적인 중복 데이터 제거 수단임)
  

## Map
- key, value를 하나의 entry로 묶어서 관리 (Map.Entry)가 Set으로 관리됨.
- key 중복x
- value 중복허용

### Map 인터페이스
- 추가, 수정
  - put
  - putAll
- 조회
  - entrySet
  - keySet
  - get
  - values
  - size
  - isEmpty
  - containsKey
  - containsValue
- 삭제
  - clear
  - remove

```java
public class MapTest {
    Map<String, String> hMap = new HashMap<>();

    private void addMethod() {
        System.out.println("추가 성공?: " + hMap.put("andy", "1234")); // 이전값리턴 null
        // 동일한 키의 사용 결과는?
        System.out.println("추가 성공?: " + hMap.put("andy", "4567")); // 이전값리턴: 1234
        hMap.put("kate", "9999"); 
        // 기존에 해당 키에 대한 값이 없을 때만 추가하기
        hMap.putIfAbsent("kate", "1234"); // 안들어감 이미 kate 있음

        hMap.put("henry", "4567"); // 동일한 값 중복 상관없음

        hMap.put("hong", "1234");
        System.out.println("추가 결과: " + hMap);
    }

    private void retrieveMethod() {
        // TODO: kate의 전화번호가 있나요?
    	System.out.println(hMap.get("Kate"));
        // END

        // TODO: map이 가지고 있는 key와 거기에 연결된 value를 출력하시오.
    	Set<String> keys = hMap.keySet();
    	for (String k : keys) {
    		System.out.println(hMap.get(k));
    	}
    	
    	Set<Entry<String, String>> entries = hMap.entrySet();
    	for (Entry<String, String> e : entries) {
    		System.out.println(e.getKey() + " " + e.getValue());
    	}
        // END

        // TODO: 값이 4567인 사람의 이름은?
    	// 값으로 조회하는 방법은 없음
    	Set<Entry<String, String>> ent = hMap.entrySet();
    	for (Entry<String, String> e : ent) {
    		if (hMap.get(e.getKey()).equals("4567")) {
    			System.out.println(e.getKey());
    		}
    	}
        // END
    }

    private void removeMethod() {
        // TODO: andy의 자료를 삭제하고 출력하시오.
    	hMap.remove("andy");
        // END
    }

    public static void main(String[] args) {
        MapTest hmt = new MapTest();
        hmt.addMethod();
        hmt.retrieveMethod();
        hmt.removeMethod();
    }
}


```

## 정렬
- 정렬 가능한 컬렉션
  - 배열, List
  - SortedSet
  - SortedMap(key 기준)

- `Collections.sort(list)` 하면됨
  - String, Integer은 자동정렬됨
  - 클래스는 Comparable 인터페이스 구현해야함

```java
public class SmartPhone implements Comparable<SmartPhone> {
    String number;

    @Override
    public int compareTo(SmartPhone o) {
        return this.number.compareTo(o.number);
    }

```

### Comparable

### Comparator
- 객체가 Comparable을 구현하지 않거나, 사용자 정의 알고리즘으로 정렬하려는 경우

### 익명 클래스
- anonymous inner class


### 람다 표현식